> **Language policy (v1.0-first, English default):**
> - Primary language for repo documentation: English.
> - Baseline is v1.0; v1.1 changes are documented as extension notes only.
> - 한국어는 보조 문맥(필요 시)로 제공됩니다.

# 멀티 모델/멀티 에이전트 토큰 최적화 플레이북 (OhMyCode + Claude Code + Codex + Gemini + Antigravity)

> 목표: **“모델을 더 쓰는 것”이 아니라, “필요할 때만 비싼 모델을 쓰는 구조”**로 바꿔서  
> 같은 작업량을 **훨씬 적은 토큰/크레딧**으로 처리하기.

---

## 1) 먼저 용어 정리: “토큰”이 아니라 “사용 한도(usage limit)”인 경우가 많아요

- **구독형(챗 UI / Claude Pro·Max, Gemini Advanced 등)**: 보통 “메시지/용량/사용량” 한도가 있고, 이를 흔히 “토큰 다 썼다”라고 표현.
- **API형(키를 넣고 쓰는 Codex CLI, Antigravity(설정에 따라), OhMyCode(설정에 따라))**:  
  **요청마다 과금** + **조직/프로젝트의 spend limit & rate limit**로 관리.

즉, “한도가 공유되는가?”는 **어떤 방식(구독 vs API)으로 연결했는가**에 따라 달라집니다.

---

## 2) ‘한도 공유’는 실제로 일어납니다 (특히 Claude)

### Claude Pro/Max + Claude Code
- **Pro/Max의 사용 한도는 Claude(웹/앱)와 Claude Code(터미널) 사이에서 공유**됩니다.  
  → Claude Code로 많이 쓰면 웹에서 다른 Claude 모델도 제한에 걸릴 수 있어요.
- Claude Code에는 요금제별 **사용량/레이트 리밋 정책**이 따로 안내되는 경우도 있어요.

---

## 3) Codex / OpenAI 쪽은 “어떻게 연결했는지”가 핵심

- Codex CLI는 보통 **OpenAI API 기반**으로 동작하며, 사용량을 확인하고 비용 최적화(모델/컨텍스트/출력 제한)를 안내합니다.
- 따라서 Codex를 **ChatGPT 구독 한도(메시지 캡)**로 쓰는지, **API 키(과금형)**로 쓰는지에 따라 체감이 크게 달라질 수 있어요.

---

## 4) “Claude → Codex → Gemini → Zen” 순차로 돌리는 게 최적이냐?

결론: **보통은 비효율적**입니다.

왜냐하면:
- 모델을 바꿀 때마다 **컨텍스트(설명·로그·코드·의도)를 다시 읽히는 비용**이 발생
- 멀티 에이전트는 한 번 요청이 **N개로 분기**(planner/reviewer/tester 등)하면서 사용량이 기하급수로 늘어남
- “검증”을 매번 모든 모델로 하는 건 대부분 과잉 품질

✅ 더 좋은 구조는 **‘순차 사용’이 아니라 ‘승급(에스컬레이션) 사용’**입니다.

---

## 5) 추천 운영 방식: 2-모델 2-에이전트로 시작

### (A) 기본형: Builder 1명 + Reviewer 1명
- **Builder(주력 모델)**: 대부분의 구현/수정/리팩토링을 처리
- **Reviewer(보조 모델, 다른 회사 모델 권장)**: 병합 전/큰 변경 전 “리스크·버그·누락”만 체크

> 멀티 에이전트를 늘리는 건 “규모가 커지고 규칙이 정해진 다음”이 좋아요.

### (B) 승급 규칙 (예시)
1. **일상 작업(90%)**: 중간급 모델(가성비 좋고 빠른 모델)
2. **막혔을 때만(10%)**: 최고급 모델 1~2회로 ‘돌파’
3. **최종 검증(병합 전 1회)**: 다른 벤더 모델로 교차검증

---

## 6) 사용량을 가장 많이 잡아먹는 3가지와 해결법

### 1) “전체 코드를 붙여넣기”
✅ 해결: **diff/패치 기반**으로 요청  
- “현재 파일 전체”가 아니라, **바꿔야 할 부분 + 주변 20~40줄**만 제공
- 가능하면 `git diff` 붙이기

### 2) “로그를 통째로 붙여넣기”
✅ 해결: 로그는 먼저 **요약(규칙 기반)** 후, 필요한 구간만 제공  
- 에러 20줄 + 직전 50줄 정도면 대부분 충분

### 3) “에이전트가 서로 장황하게 대화”
✅ 해결: 에이전트 역할을 **짧은 출력 규격**으로 강제
- “결론 5줄 + 근거 5줄 + 체크리스트 5개” 같은 포맷

---

## 7) ‘스킬(재사용 프롬프트/워크플로우)’로 최적화하는 핵심

스킬의 본질은 아래 3가지를 강제하는 겁니다:

1. **출력 포맷 고정** (장황함 방지)  
2. **입력 범위 제한** (“이 파일/이 함수/이 로그만”)  
3. **작업 분해** (한 번에 큰 작업 금지)

---

## 8) 지금 당장 적용 가능한 룰 (오늘부터)

### 룰 1) “Planner”를 없애거나 최소화
- 기획/명세는 **repo의 1개 문서**로 고정: `SPEC.md`
- 대화로 기획을 계속 반복하지 말고, **문서만 업데이트**

### 룰 2) 작업 단위를 30~60분짜리로 쪼개기
- “로그인 구현” 같은 큰 단위 →  
  “라우트 추가 → 테스트 → 에러 처리 → UI 연결”로 쪼갬

### 룰 3) 모델 호출 전에 로컬 도구로 먼저 거르기
- `pytest`, `mypy`, `ruff`, `grep`로 1차 확인
- LLM은 “사람이 막히는 지점”에만 사용

### 룰 4) 멀티 모델 교차검증은 “병합 전 1회”만
- 매 커밋마다 Claude→Codex→Gemini 하면 거의 무조건 과소비

---

## 9) 한도 다 썼을 때의 플랜 B

### 구독형(Claude Pro/Max, Gemini Advanced 등)
- **리셋/롤링 윈도우 대기**
- **플랜 업그레이드/추가 용량 옵션**
- 당장 급하면 **API 키 기반 워크플로우로 우회**(비용은 들지만 “막히는 것”은 줄어듦)

### API형(Codex CLI, OhMyCode, Antigravity(키 사용 시))
- **월간 spend limit**을 낮게 걸어 “폭주”를 막고
- 작업 시간대에만 limit를 올렸다가 다시 내리는 식으로 운영

---

## 10) 프롬프트 템플릿 (짧게, 강제 포맷)

### (1) Builder 템플릿
- 목표: {한 줄}
- 범위: {파일/함수/라우트만}
- 제약: {테스트/호환성/보안}
- 출력: `git diff`만, 설명 5줄 이내

### (2) Reviewer 템플릿
- 변경 diff: {붙여넣기}
- 검토 관점: (보안/에러처리/성능/엣지케이스)
- 출력: (1) 치명 3개 (2) 중간 5개 (3) 개선 5개

### (3) 로그 디버깅 템플릿
- 현상: {한 줄}
- 재현: {명령어 1~3개}
- 핵심 로그: {에러 20줄 + 직전 50줄}
- 기대: {정상 동작}

---

## 11) OhMyCode 운영 권장값(일반 원칙)
> 도구마다 설정 키는 다르지만 원칙은 동일합니다.

- 에이전트 수: **2명부터**
- 출력 토큰 제한: **작게**
- “긴 대화 유지” 비활성화(또는 요약만 유지)
- 리포지토리/파일 검색은 **툴(검색)**로 하고 LLM에게 “전체 파일 읽기”를 덜 시키기

---

## 12) 오늘 적용 체크리스트 (10분)

- [ ] `SPEC.md` 만들고 “현재 목표/범위/금지사항/Done 정의”를 30줄 안으로 작성
- [ ] 에이전트 2명(Builder/Reviewer)만 남기고 나머지 끄기
- [ ] Builder 출력은 `git diff`로만 받기
- [ ] “교차검증”은 병합 전 1회로 제한
- [ ] 로컬 테스트/린트 먼저 돌리고, 실패 시에만 LLM 호출

---

### 부록: 가장 중요한 한 줄
**“모델을 바꾸기 전에, 문제를 작게 만들고 컨텍스트를 작게 만들어라.”**